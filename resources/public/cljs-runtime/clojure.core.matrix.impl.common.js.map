{"version":3,"sources":["clojure/core/matrix/impl/common.cljc"],"mappings":"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","names":["clojure.core.matrix.impl.common/get-impl-objs","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core/second","iter__4582__auto__","s__26230","cljs.core/LazySeq","temp__5735__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4580__auto__","size__4581__auto__","cljs.core/count","b__26232","cljs.core/chunk-buffer","i__26231","vec__26234","cljs.core._nth.cljs$core$IFn$_invoke$arity$2","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__26229","cljs.core/chunk-rest","vec__26240","cljs.core/first","cljs.core/cons","cljs.core/rest","name","ns","clojure.core.matrix.implementations/KNOWN-IMPLEMENTATIONS","cljs.core/not","fexpr__26238","fexpr__26243","e26239","e26244","clojure.core.matrix.implementations.get_canonical_object.cljs$core$IFn$_invoke$arity$1","js/Error","t","clojure.core.matrix.impl.common/construct-matrix","impl","data","or__4185__auto__","clojure.core.matrix.protocols/construct-matrix","e26249","clojure.core.matrix.implementations/*matrix-implementation*","clojure.core.matrix.impl.common/ClassCastException","var_args","G__26256","clojure.core.matrix.impl.common/mapmatrix","args-arr__4810__auto__","len__4789__auto__","i__4790__auto__","argseq__4811__auto__","cljs.core/IndexedSeq","seq26251","G__26252","cljs.core/next","G__26253","G__26254","G__26255","self__4776__auto__","f","m","dims","cljs.core/long","clojure.core.matrix.protocols/dimensionality","G__26257","x__25978__auto__","clojure.core.matrix.protocols/get-0d","cljs.core.map.cljs$core$IFn$_invoke$arity$2","clojure.core.matrix.protocols/element-seq","res","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","clojure.core.matrix.protocols/get-major-slice-seq","clojure.core.matrix.protocols/reshape","clojure.core.matrix.protocols/coerce-param","cljs.core/vec","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","clojure.core.matrix.protocols/get-shape","m1","m2","G__26259","G__26260","cljs.core.map.cljs$core$IFn$_invoke$arity$3","m3","G__26261","G__26262","G__26263","cljs.core.map.cljs$core$IFn$_invoke$arity$4","cljs.core.mapv.cljs$core$IFn$_invoke$arity$4","more","cljs.core.apply.cljs$core$IFn$_invoke$arity$5","cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic","cljs.core/map","clojure.core.matrix.impl.common/logistic-fn","e-t","G__26270","Math/exp","clojure.core.matrix.impl.common/softplus-fn","et","G__26274","Math/log","clojure.core.matrix.impl.common/relu-fn","Math/max","clojure.core.matrix.impl.common/square?","clojure.core.matrix.protocols/dimension-count","clojure.core.matrix.impl.common/symmetric-matrix-entries?","dim","i","j","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","clojure.core.matrix.protocols/get-2d","cljs.core/chunk-first"],"sourcesContent":["(ns clojure.core.matrix.impl.common\n  \"Namespace containing common functions useful for core.matrix implementatations\"\n  (:require [clojure.string :as s]\n            [clojure.core.matrix.protocols :as mp]\n            [clojure.core.matrix.utils :as u]\n            [clojure.core.matrix.implementations :as mi]\n    #?(:clj [clojure.java.shell :refer [sh]]))\n  (#?(:clj :require :cljs :require-macros)\n           [clojure.core.matrix.macros :refer [scalar-coerce]]))\n\n(defn get-impl-objs\n  \"Returns a list of available implementations' objects\"\n  []\n  (filter second\n          (for [[name ns] mi/KNOWN-IMPLEMENTATIONS\n                :when (not (#{:TODO :persistent-vector} ns))]\n            (try\n              {:name name, :obj (mi/get-canonical-object name)}\n              (catch #?(:clj Throwable :cljs js/Error) t nil)))))\n\n#?(:clj (do\n\n(defn find-implementers\n  \"Returns a set of implementation names of implementations that\n   support provided protocol\"\n  [protocol impl-objs]\n  (->> impl-objs\n       (filter #(->> % :obj class (u/extends-deep? protocol)))\n       (map :name)\n       (into #{})))\n\n(defn extract-implementations\n  \"Returns a a sequence of protocol maps augmented with :implemented-by key\n   that contains a set of names of supporting implementations\"\n  [protocols impl-objs]\n  (for [proto protocols]\n    (assoc proto :implemented-by (find-implementers proto impl-objs))))\n\n(defn get-git-hash\n  \"Returns current revision's git hash\"\n  []\n  (-> (sh \"git\" \"log\" \"--pretty=format:'%H'\" \"-n 1\")\n      :out\n      (s/replace #\"'\" \"\")))\n\n))\n\n(defn construct-matrix\n  \"Constructs an array from the provided data, attempting to use the given implementation.\n   Uses a default implementation if needed\"\n  ([impl data]\n    (or (mp/construct-matrix impl data)\n        (try \n          (mp/construct-matrix mi/*matrix-implementation* data)\n          (catch ClassCastException t nil)) ;; fix for element type not handled\n        (mp/construct-matrix [] data))))\n\n(defn mapmatrix\n  \"Maps a function over all components of a persistent vector matrix. Like mapv but for matrices.\n   Assumes correct dimensionality / shape.\n\n   First array argument must be nested persistent vectors. Others may be\n   any arrays of the same shape.\n\n   Returns a nested persistent vector matrix or a scalar value.\"\n  ([f m]\n   (let [dims (long (mp/dimensionality m))]\n     (cond\n       (== 0 dims) (f (scalar-coerce m))\n       (== 1 dims) (construct-matrix m\n                     (map f (mp/element-seq m)))\n       :else\n       (let [res (map (partial mapmatrix f) (mp/get-major-slice-seq m))]\n         (mp/reshape (mp/coerce-param m res)\n                     (vec (concat [(first (mp/get-shape m))] (next (mp/get-shape res)))))))))\n  ([f m1 m2]\n    (let [dims (long (mp/dimensionality m1))]\n      (cond\n        (== 0 dims) (f (scalar-coerce m1) (scalar-coerce m2))\n        (== 1 dims) (construct-matrix m1\n                      (map f (mp/element-seq m1) (mp/element-seq m2)))\n        :else\n        (let [res (map (partial mapmatrix f) (mp/get-major-slice-seq m1) (mp/get-major-slice-seq m2))]\n          (mp/reshape (mp/coerce-param m1 res)\n            (vec (concat [(first (mp/get-shape m1))] (next (mp/get-shape res)))))))))\n  ([f m1 m2 m3]\n    (let [dims (long (mp/dimensionality m1))]\n      (cond\n        (== 0 dims) (f (scalar-coerce m1) (scalar-coerce m2) (scalar-coerce m3))\n        (== 1 dims) (construct-matrix m1\n                      (map f (mp/element-seq m1) (mp/element-seq m2) (mp/element-seq m3)))\n        :else\n        (let [res (mapv (partial mapmatrix f)\n                        (mp/get-major-slice-seq m1)\n                        (mp/get-major-slice-seq m2)\n                        (mp/get-major-slice-seq m3))]\n          (mp/reshape (mp/coerce-param m1 res)\n            (vec (concat [(first (mp/get-shape m1))] (next (mp/get-shape res)))))))))\n  ([f m1 m2 m3 & more]\n    (let [dims (long (mp/dimensionality m1))]\n      (cond\n        (== 0 dims) (apply f (scalar-coerce m1) (scalar-coerce m2)\n                           (scalar-coerce m3) (map mp/get-0d more))\n        (== 1 dims) (construct-matrix m1\n                      (apply map f (mp/element-seq m1) (mp/element-seq m2)\n                             (mp/element-seq m3) (map mp/element-seq more)))\n        :else\n        (let [res (apply map (partial mapmatrix f)\n                         (mp/get-major-slice-seq m1)\n                         (mp/get-major-slice-seq m2)\n                         (mp/get-major-slice-seq m3)\n                         (map mp/get-major-slice-seq more))]\n          (mp/reshape (mp/coerce-param m1 res)\n            (vec (concat [(first (mp/get-shape m1))] (next (mp/get-shape res))))))))))\n\n(defn logistic-fn\n  \"Logistic function, with primitive type hints\"\n  (^double [^double t]\n    (let [e-t (Math/exp (- t))]\n      (/ 1.0 (+ 1.0 e-t)))))\n\n(defn softplus-fn\n  \"Softplus function, with primitive type hints\"\n  (^double [^double t]\n    (if (> t 100.0) ;; catch the case of overflow to infinity for large inputs\n      t\n      (let [et (Math/exp t)]\n        (Math/log (+ 1.0 et))))))\n\n(defn relu-fn\n  \"ReLU function, with primitive type hints\"\n  (^double [^double t]\n    (Math/max 0.0 t)))\n\n(defn square?\n  \"Returns true if matrix is square (2D with same number of rows and columns)\"\n  ([m]\n    (and\n      (== 2 (long (mp/dimensionality m)))\n      (== (long (mp/dimension-count m 0)) (long (mp/dimension-count m 1))))))\n\n;; Helper function for symmetric? predicate in PMatrixPredicates.\n;; Note loop/recur instead of letfn/recur is 20-25% slower.\n;; not possible to eliminate boxing warnings - needs to handle any numeric type\n(defn symmetric-matrix-entries?\n  \"Returns true iff square matrix m is symmetric.\"\n  [m]\n  (let [dim (long (first (mp/get-shape m)))]\n    (letfn [(f [^long i ^long j]\n              (cond\n                (>= i dim) true                         ; all entries match: symmetric\n                (>= j dim) (recur (+ 1 i) (+ 2 i))      ; all j's OK: restart with new i\n                (= (mp/get-2d m i j)\n                   (mp/get-2d m j i)) (recur i (inc j)) ; OK, so check next pair\n                :else false))]                          ; not same, not symmetric\n      (f 0 1))))\n\n"]}